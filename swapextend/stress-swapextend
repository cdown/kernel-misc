#!/bin/bash -ex

# Exercise new swapextend syscall.

: "${SCNR:=439}"

swap_file=/se_swapfile
next_megs=1

_resize_file() {
    local _new_megs=${1?}
    fallocate -l "$_new_megs"M "$swap_file"
}

_swapextend() {
    local _new_size=${1:-0}
    ./swapextend "$SCNR" "$swap_file" "$_new_size"
}

die() {
    local _exit_code=${1?}
    local _msg=${2?}
    printf 'FATAL: %s\n' "$_msg" >&2
    exit "$_exit_code"
}

swapextend() {
    local _new_megs=${1?}
    _resize_file "$_new_megs"
    _swapextend 0
}

leak_forever() {
    while :; do ./leaker >/dev/null; done
}

cleanup() {
    # Make sure we only use our swap_file to have the maximum chance to find
    # issues
    swapoff -a
    rm -f "$swap_file"
}

setup() {
    # Otherwise leaker might get killed.
    echo -1000 > /proc/self/oom_score_adj

    # Otherwise the session might go away
    echo -1000 > /proc/"$(pgrep -ox systemd-logind)"/oom_score_adj

    make swapextend
    make leaker
    cleanup

    fstype=$(df --output=fstype / | tail -1)
    if [[ $fstype == btrfs ]]; then
        truncate -s 0 "$swap_file"
        chattr +C "$swap_file"
    fi

    _resize_file "$next_megs"
    (( next_megs++ ))
    chmod 600 "$swap_file"
    mkswap "$swap_file"
    swapon "$swap_file"
}

main() {
    trap cleanup EXIT
    setup

    if (( $# == 0 )); then
        mode=stress
    else
        case $1 in
            --stress) mode=stress ;;
            --slow) mode=slow ;;
            --leak) mode=leak ;;
            *) die 1 "Unknown mode: $1" ;;
        esac
    fi

    if [[ $mode == leak ]]; then
        leak_forever &
    fi

    while :; do
        swapextend "$next_megs"
        (( next_megs++ ))
        if [[ $mode == leak ]] || [[ $mode == slow ]]; then
            sleep 5
        fi
    done
}

main "$@"
